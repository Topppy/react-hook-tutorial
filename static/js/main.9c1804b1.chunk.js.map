{"version":3,"sources":["views/StateHook.js","views/EffectHook.js","views/Rules.js","views/Home.js","views/CustomHooks.js","App.js","serviceWorker.js","index.js"],"names":["Counter","_useState","useState","_useState2","Object","slicedToArray","count","setCount","react_default","a","createElement","onClick","default_highlight","language","style","docco","defaultTitle","document","title","EffectHook","useEffect","concat","Rules","_useState3","_useState4","double","setDouble","_useState5","_useState6","three","setThree","href","Home","CustomHooks","AppRouter","BrowserRouter","Link","to","Route","path","exact","component","StateHook","Boolean","window","location","hostname","match","ReactDOM","render","App","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.9c1804b1.chunk.js","sourcesContent":["import React, { useState } from 'react';\nimport SyntaxHighlighter from 'react-syntax-highlighter';\nimport { docco } from 'react-syntax-highlighter/dist/styles/hljs';\n\n\nexport default function Counter() {\n  // Declare a new state variable, which we'll call \"count\"\n  /**\n   * useState returns a pair: the current state value and a function that lets you update it.\n   * userState 返回两个值，一个是当前的state值，另一个是更新state的func\n   */\n  const [count, setCount] = useState(0);\n\n  return (\n    <div>\n      <h1>State Hook</h1>\n      <p>You clicked {count} times</p>\n      <button onClick={() => setCount(count + 1)}>\n        Click me\n      </button>\n      <p>源码如下，</p>\n      <SyntaxHighlighter language='javascript' style={docco}>\n        {`\n          import { useState } from 'react';\n\n          function Example() {\n            // Declare a new state variable, which we'll call \"count\"\n            const [count, setCount] = useState(0);\n\n            return (\n              <div>\n                <p>You clicked {count} times</p>\n                <button onClick={() => setCount(count + 1)}>\n                  Click me\n                </button>\n              </div>\n            );\n          }\n        `}\n      </SyntaxHighlighter>\n      介绍：\n      <ul>\n        <li>userState 返回两个值，一个是当前的state值，另一个是更新state的func</li>\n        <li>这个更新state的func与this.setState类似，除了它并不merge旧的state</li>\n        <li>useState只接受一个参数，就是初始state，注意到与this.state不同，这个state可以不是对象（也可以是对象）</li>\n        <li>如果多次调用useState，每次render都会按照你写的seState顺序执行</li>\n        <li>Hooks无法在class组件中使用，只能在function组件中使用</li>\n        <li>Hooks支持自定义</li>\n      </ul>\n      使用：\n      <ul>\n        <li>import useState</li>\n        <li>获取当前state： count，和stateUpdater： setCount，（解构赋值）</li>\n        <li>在jsx中直接使用' count '</li>\n        <li>在click handler中直接使用setCount</li>\n      </ul>\n    </div>\n  );\n}","import React, { useState, useEffect } from 'react';\nimport SyntaxHighlighter from 'react-syntax-highlighter';\nimport { docco } from 'react-syntax-highlighter/dist/styles/hljs';\n\nconst defaultTitle = document.title\n\nexport default function EffectHook() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    document.title = `You clicked ${count} times`;\n    return () => {\n      document.title = defaultTitle\n    }\n  });\n\n  return (\n    <div>\n      <h1>Effect Hook</h1>\n      <h3>简单例子</h3>\n      <p>You clicked {count} times</p>\n      <button onClick={() => setCount(count + 1)}>\n        Click me\n      </button>\n      <p>源码如下，</p>\n      <SyntaxHighlighter language='javascript' style={docco}>\n        {`\n          import { useState, useEffect } from 'react';\n          const defaultTitle = document.title\n\n          function Example() {\n            const [count, setCount] = useState(0);\n          \n            // Similar to componentDidMount and componentDidUpdate:\n            useEffect(() => {\n              // Update the document title using the browser API\n              document.title = ${`You clicked $\\{count} times`};\n              // Similar to componentWillUnmount\n              // Specify how to clean up after this effect:\n              return () => {\n                document.title = defaultTitle\n              }\n            });\n          \n            return (\n              <div>\n                <p>You clicked {count} times</p>\n                <button onClick={() => setCount(count + 1)}>\n                  Click me\n                </button>\n              </div>\n            );\n          }\n        `}\n      </SyntaxHighlighter>\n      介绍：\n      <ul>\n        <li>EffectHook给了function组件执行带有副作用操作（称为effects）的能力，eg. 请求数据、订阅、改变DOM</li>\n        <li>EffectHook与Class组件的componentDidMount, componentDidUpdate和 componentWillUnmount的使用场景是类似的</li>\n        <li>EffectHook在每次render后执行，就是说，首次DidMount和更新的DidUpdate时，EffectHook都会执行</li>\n        <li>组件卸载的时候也会经过EffectHook，不过执行的是不再是EffectHook本身，而是EffectHook return的fucntion。</li>\n        <li>EffectHook也可以像StateHook一样在一个组件中Home多次使用</li>\n      </ul>\n      effects分为两种：\n      <ul>\n        <li>不需要clean up的，比如数据请求，改变DOM等，执行完就不用再管了</li>\n        <li>需要clean up的，比如订阅，定时器等，需要在组件变更／销毁的时候清理一下，避免内存泄漏</li>\n      </ul>\n      <h3>不需要清理的Effects</h3>\n      几个引导性问答：\n      <ul>\n        <li>useEffect是干什么用的？</li>\n        <p>使用EffectHook来告诉react在render后执行一些事情，React会保存你传递给useEffect的函数，并在DOM更新之后执行</p>\n        <li>为什么在组件內调用useEffect？</li>\n        <p>可以利用闭包的特性来访问state，props</p>\n        <li>useEffect每次render之后都会执行么？</li>\n        <p>是的。react保证在每次DOM更新后调用useEffect</p>\n      </ul>\n      与componentDidMount, componentDidUpdate的一个关键性差异在于：\n      <ul>\n        <li>useEffect调度的effects不会阻塞浏览器更新，会延迟到浏览器绘制完后执行，响应体验更好</li>\n      </ul>\n      <h3>需要清理的Effects</h3>\n      几个引导性问答\n      <ul>\n        <li>为什么effect要return一个function？</li>\n        <p>这是effects的可选清理机制，每个effect都可以return一个fucntion用来清理自己</p>\n        <li>什么时候React会清理effect的？</li>\n        <p>组件卸载的时候，react会执行清理。</p>\n        <p>然而，上文中提到，react会在每次render的时候都执行effects，而不是只执行一次。</p>\n        <p>因此实际上，react在执行下次effects前也会清理掉上次的effects</p>\n      </ul>\n      <h3>其他</h3>\n      <h4>useEffect与class相比的优势</h4>\n      <ul>\n        <li>useEffect将原本分散在componentDidMount, componentDidUpdate和 componentWillUnmount三个周期內的相关逻辑集中到了一起</li>\n        <li>useEffect将原本混和在同一个周期里的多个互不相关的逻辑，通过多个effects区分开来</li>\n      </ul>\n      <h4>为什么每次更新都要执行effects</h4>\n      <ul>\n        <li>一个class的例子</li>\n        <SyntaxHighlighter language='javascript' style={docco}>\n          {`\n            class FriendStatusWithCounter extends React.Component {\n              constructor(props) {\n                super(props);\n                this.state = { isOnline: null };\n                this.handleStatusChange = this.handleStatusChange.bind(this);\n              }\n            \n              componentDidMount() {\n                ChatAPI.subscribeToFriendStatus(\n                  this.props.friend.id,\n                  this.handleStatusChange\n                );\n              }\n              // 当props的friend.id改变的时候,如果我们不做额外处理（下述代码）\n              // 就会出现依旧订阅的是旧数据的bug\n              componentDidUpdate(prevProps) {\n                // 需要取消订阅旧id\n                ChatAPI.unsubscribeFromFriendStatus(\n                  prevProps.friend.id,\n                  this.handleStatusChange\n                );\n                // 重新订阅新id\n                ChatAPI.subscribeToFriendStatus(\n                  this.props.friend.id,\n                  this.handleStatusChange\n                );\n              }\n            \n              componentWillUnmount() {\n                ChatAPI.unsubscribeFromFriendStatus(\n                  this.props.friend.id,\n                  this.handleStatusChange\n                );\n              }\n            \n              handleStatusChange(status) {\n                this.setState({\n                  isOnline: status.isOnline\n                });\n              }\n              // ...\n          `}\n        </SyntaxHighlighter>\n        <li>如果使用hooks来实现这个需求</li>\n        <SyntaxHighlighter language='javascript' style={docco}>\n          {`\n          function FriendStatusWithCounter(props) {\n            const [isOnline, setIsOnline] = useState(null);\n            useEffect(() => {\n              ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);\n              return () => {\n                ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);\n              };\n            });\n          \n            function handleStatusChange(status) {\n              setIsOnline(status.isOnline);\n            }\n            // ...\n          }\n          `}\n        </SyntaxHighlighter>\n        <li>react通过每次都render都执行effects帮我们解决了这个问题，它实际调用如下：</li>\n        <SyntaxHighlighter language='javascript' style={docco}>\n          {`\n            // Mount with { friend: { id: 100 } } props\n            ChatAPI.subscribeToFriendStatus(100, handleStatusChange);     // Run first effect\n            \n            // Update with { friend: { id: 200 } } props\n            ChatAPI.unsubscribeFromFriendStatus(100, handleStatusChange); // Clean up previous effect\n            ChatAPI.subscribeToFriendStatus(200, handleStatusChange);     // Run next effect\n            \n            // Update with { friend: { id: 300 } } props\n            ChatAPI.unsubscribeFromFriendStatus(200, handleStatusChange); // Clean up previous effect\n            ChatAPI.subscribeToFriendStatus(300, handleStatusChange);     // Run next effect\n            \n            // Unmount\n            ChatAPI.unsubscribeFromFriendStatus(300, handleStatusChange); // Clean up last effect\n          `}\n        </SyntaxHighlighter>\n      </ul>\n      <h4>优化</h4>\n      <ul>\n        <li>既然每次render都会执行effects，那么会不会造成性能问题？<br/> \n        在class组件中，我们会比较prevState，prevProps，只在关心的数据变化的时候才执行操作。<br/> \n        useEffect考虑到了这点，并且内置了这个这个功能，你可以主动告诉React在re-render的时候，如果你关心的那个值没有改变，那么本次就跳过执行effects。</li>\n        <li>useEffect支持第二个参数，数组类型，数组元素为我们要优化的那个变量名</li>\n        <SyntaxHighlighter>\n          {`\n            // 简单例子\n            useEffect(() => {\n              document.title = ${`You clicked $\\{count} times`};\n            }, [count]); // Only re-run the effect if count changes\n\n            // 另一个例子\n            useEffect(() => {\n              ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);\n              return () => {\n                ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);\n              };\n            }, [props.friend.id]); // Only re-subscribe if props.friend.id changes\n          `}\n        </SyntaxHighlighter>\n        如果只想在mount执行一次effects和unmount的时候执行一次清理，那么第二个参数传递空数组，这个effects不会重复执行。<br/>\n        因此，第二参数传递[]的时候，useEffect会更接近componentDidMount和componentWillUnmount的效果。\n      </ul>\n\n\n    </div>\n  );\n}\n","import React, { useState } from 'react';\nimport SyntaxHighlighter from 'react-syntax-highlighter';\nimport { docco } from 'react-syntax-highlighter/dist/styles/hljs';\n\nexport default function Rules() {\n  const [count, setCount] = useState(0);\n  const [double, setDouble] = useState(0);\n  const [three, setThree] = useState(0);\n\n  return (\n    <div>\n      <h1>Hooks规则：</h1>\n      <p>You clicked +1 button {count} times</p>\n      <p>You clicked +2 button {double} times</p>\n      <p>You clicked +3 button {three} times</p>\n      <button onClick={() => setCount(count + 1)}>\n        +1\n      </button>\n      <button onClick={() => setDouble(double + 1)}>\n        +2\n      </button>\n      <button onClick={() => setThree(three + 1)}>\n        +3\n      </button>\n      <ul>\n        <li>只能在顶级调用Hooks。</li>\n        <p>不能在循环，条件判断，嵌套函数中调用Hooks。确保每次render的时候，hooks都是相同的顺序</p>\n        <li>不能在普通的js函数中调用Hooks</li>\n        <ol>\n          <li>可以在React function组件中调用Hooks。</li>\n          <li>可以在自定义Hooks中调用Hooks。</li>\n        </ol>\n      </ul>\n      官方提供<a href='https://www.npmjs.com/package/eslint-plugin-react-hooks'>linter</a>来校验这些规则\n\n      <h3>为什么不Hooks要保证顺序不变？</h3>\n      <p>当一个fucntion组件中有多个Hooks时，React是如何知道每个useState对应的是哪个state？</p>\n      <p>React官方给的答案是：React依赖于Hooks被调用的顺序。当然我看完并没有明白为啥，于是在源码useState函数里打了断点</p>\n      <p>最后定位到react-dom源码的useReducer函数，在该函数中，workInProgressHook是以单链表的方式存放Hooks，React只能按照顺序使用next来逐一执行每个Hook，无法跳过</p>\n      <SyntaxHighlighter language='javascript' style={docco}>\n        {`\n        function useReducer(reducer, initialState, initialAction) {\n          currentlyRenderingFiber$1 = resolveCurrentlyRenderingFiber();\n          workInProgressHook = createWorkInProgressHook();\n          var queue = workInProgressHook.queue;\n          if (queue !== null) {\n            // Already have a queue, so this is an update.\n            if (isReRender) {\n              // This is a re-render. Apply the new render phase updates to the previous\n              var _dispatch2 = queue.dispatch;\n              if (renderPhaseUpdates !== null) {\n                // Render phase updates are stored in a map of queue -> linked list\n                var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);\n                if (firstRenderPhaseUpdate !== undefined) {\n                  renderPhaseUpdates.delete(queue);\n                  var newState = workInProgressHook.memoizedState;\n                  var update = firstRenderPhaseUpdate;\n                  do {\n                    // Process this render phase update. We don't have to check the\n                    // priority because it will always be the same as the current\n                    // render's.\n                    var _action = update.action;\n                    newState = reducer(newState, _action);\n                    update = update.next;\n                  } while (update !== null);\n        \n                  workInProgressHook.memoizedState = newState;\n        \n                  // Don't persist the state accumlated from the render phase updates to\n                  // the base state unless the queue is empty.\n                  // TODO: Not sure if this is the desired semantics, but it's what we\n                  // do for gDSFP. I can't remember why.\n                  if (workInProgressHook.baseUpdate === queue.last) {\n                    workInProgressHook.baseState = newState;\n                  }\n        \n                  return [newState, _dispatch2];\n                }\n              }\n              return [workInProgressHook.memoizedState, _dispatch2];\n            }\n        \n            // The last update in the entire queue\n            var _last = queue.last;\n            // The last update that is part of the base state.\n            var _baseUpdate = workInProgressHook.baseUpdate;\n        \n            // Find the first unprocessed update.\n            var first = void 0;\n            if (_baseUpdate !== null) {\n              if (_last !== null) {\n                // For the first update, the queue is a circular linked list where\n                // \\`queue.last.next = queue.first\\`. Once the first update commits, and\n                // the \\`baseUpdate\\` is no longer empty, we can unravel the list.\n                _last.next = null;\n              }\n              first = _baseUpdate.next;\n            } else {\n              first = _last !== null ? _last.next : null;\n            }\n            if (first !== null) {\n              var _newState = workInProgressHook.baseState;\n              var newBaseState = null;\n              var newBaseUpdate = null;\n              var prevUpdate = _baseUpdate;\n              var _update = first;\n              var didSkip = false;\n              do {\n                var updateExpirationTime = _update.expirationTime;\n                if (updateExpirationTime < renderExpirationTime) {\n                  // Priority is insufficient. Skip this update. If this is the first\n                  // skipped update, the previous update/state is the new base\n                  // update/state.\n                  if (!didSkip) {\n                    didSkip = true;\n                    newBaseUpdate = prevUpdate;\n                    newBaseState = _newState;\n                  }\n                  // Update the remaining priority in the queue.\n                  if (updateExpirationTime > remainingExpirationTime) {\n                    remainingExpirationTime = updateExpirationTime;\n                  }\n                } else {\n                  // Process this update.\n                  var _action2 = _update.action;\n                  _newState = reducer(_newState, _action2);\n                }\n                prevUpdate = _update;\n                _update = _update.next;\n              } while (_update !== null && _update !== first);\n        \n              if (!didSkip) {\n                newBaseUpdate = prevUpdate;\n                newBaseState = _newState;\n              }\n        \n              workInProgressHook.memoizedState = _newState;\n              workInProgressHook.baseUpdate = newBaseUpdate;\n              workInProgressHook.baseState = newBaseState;\n            }\n        \n            var _dispatch = queue.dispatch;\n            return [workInProgressHook.memoizedState, _dispatch];\n          }\n        \n          // There's no existing queue, so this is the initial render.\n          if (reducer === basicStateReducer) {\n            // Special case for \\`useState\\`.\n            if (typeof initialState === 'function') {\n              initialState = initialState();\n            }\n          } else if (initialAction !== undefined && initialAction !== null) {\n            initialState = reducer(initialState, initialAction);\n          }\n          workInProgressHook.memoizedState = workInProgressHook.baseState = initialState;\n          queue = workInProgressHook.queue = {\n            last: null,\n            dispatch: null\n          };\n          var dispatch = queue.dispatch = dispatchAction.bind(null, currentlyRenderingFiber$1, queue);\n          return [workInProgressHook.memoizedState, dispatch];\n        }\n        `}\n      </SyntaxHighlighter>\n      <p>那么，如果你需要使用条件判断，可以移到Hooks的effects函数内部</p>\n      <SyntaxHighlighter language='javascript' style={docco}>\n        {`\n         useEffect(function persistForm() {\n          // 👍 We're not breaking the first rule anymore\n          if (name !== '') {\n            localStorage.setItem('formData', name);\n          }\n        });\n        `}\n      </SyntaxHighlighter>\n    </div>\n  );\n}","import React from 'react';\n\nexport default function Home() {\n  return (\n    <div>\n      <h1>React Hooks</h1>\n      <h3>hooks为了解决什么问题？</h3>\n      <p>逻辑复用</p>\n      <h3>class会完全被替代吗？</h3>\n      <p>也许，但是react并不打算删除掉class。</p>\n    </div>\n  );\n}","import React, { useState } from 'react';\n// import SyntaxHighlighter from 'react-syntax-highlighter';\n// import { docco } from 'react-syntax-highlighter/dist/styles/hljs';\n\n\nexport default function CustomHooks() {\n\n  return (\n    <div>\n      <h1>Custom Hook</h1>\n    </div>\n  );\n}","// import './App.css';\nimport React from \"react\";\nimport { BrowserRouter as Router, Route, Link } from \"react-router-dom\";\nimport StateHook from './views/StateHook';\nimport EffectHook from './views/EffectHook';\nimport Rules from './views/Rules';\nimport Home from './views/Home';\nimport CustomHooks from './views/CustomHooks';\n\nconst AppRouter = () => (\n  <Router>\n    <div>\n      <nav>\n        <ul>\n          <li>\n            <Link to=\"/\">Home</Link>\n          </li>\n          <li>\n            <Link to=\"/state-hook/\">State Hook</Link>\n          </li>\n          <li>\n            <Link to=\"/effect-hook/\">Effect Hook</Link>\n          </li>\n          <li>\n            <Link to=\"/rules/\">Hooks规则</Link>\n          </li>\n          <li>\n            <Link to=\"/custom-hooks/\">自定义Hooks</Link>\n          </li>\n        </ul>\n      </nav>\n\n      <Route path=\"/\" exact component={Home} />\n      <Route path=\"/state-hook/\" component={StateHook} />\n      <Route path=\"/effect-hook/\" component={EffectHook} />\n      <Route path=\"/rules\" exact component={Rules} />\n      <Route path=\"/custom-hooks\" exact component={CustomHooks} />\n    </div>\n  </Router>\n);\n\nexport default AppRouter;","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}